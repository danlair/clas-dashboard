<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>CLAS Data Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            margin: 20px;
            background: #f5f5f5;
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            background: #00447c;
            padding: 25px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            gap: 20px;
        }
        .header-logo {
            flex-shrink: 0;
        }
        .header-logo img {
            height: 80px;
            width: auto;
        }
        .header-content {
            flex: 1;
        }
        h1 {
            margin: 0 0 5px 0;
            color: white;
        }
        .subtitle {
            color: rgba(255, 255, 255, 0.9);
            margin: 0;
            font-size: 14px;
        }
        
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                text-align: center;
            }
            .header-logo img {
                height: 60px;
            }
        }
        .filters {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-left: 4px solid #00447c;
        }
        label {
            font-weight: 600;
            margin-right: 8px;
            color: #00447c;
        }
        select {
            padding: 8px 12px;
            margin-right: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        select:focus {
            outline: none;
            border-color: #00447c;
            box-shadow: 0 0 0 2px rgba(0, 68, 124, 0.1);
        }
        
        /* Metric sections */
        .metric-section {
            margin-bottom: 25px;
        }
        .section-title {
            font-size: 16px;
            font-weight: 600;
            color: #333;
            margin-bottom: 12px;
            padding-left: 5px;
            border-left: 4px solid #00447c;
            padding-left: 12px;
        }
        .kpi-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 15px;
            margin-bottom: 8px;
        }
        .kpi-card {
            background: white;
            padding: 18px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .kpi-label {
            color: #717073;
            font-size: 11px;
            text-transform: uppercase;
            font-weight: 600;
            margin-bottom: 8px;
            letter-spacing: 0.5px;
        }
        .kpi-value {
            font-size: 26px;
            font-weight: bold;
            color: #00447c;
            margin-bottom: 4px;
        }
        .kpi-change {
            font-size: 12px;
            margin-top: 5px;
        }
        .positive { color: #10b981; }
        .negative { color: #d11242; }
        .neutral { color: #717073; }
        
        .table-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow-x: auto;
            border-top: 3px solid #00447c;
        }
        .table-title {
            font-size: 18px;
            font-weight: 600;
            color: #00447c;
            margin-bottom: 15px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
            font-size: 14px;
        }
        th {
            background: #00447c;
            padding: 12px;
            text-align: left;
            font-size: 12px;
            font-weight: 600;
            color: white;
            position: sticky;
            top: 0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        tbody tr:hover {
            background: rgba(0, 68, 124, 0.05);
        }
        .metric-name {
            font-weight: 600;
            color: #00447c;
        }
        .error-message {
            background: #fff3cd;
            border: 1px solid #d11242;
            color: #856404;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-logo">
                <img src="clas-logo.png" alt="CLAS Logo">
            </div>
            <div class="header-content">
                <h1>CLAS Data Dashboard</h1>
                <p class="subtitle" id="subtitle">Loading data...</p>
            </div>
        </div>
        
        <div id="errorContainer"></div>
        
        <div class="filters">
            <label>Department:</label>
            <select id="deptSelect">
                <option value="">Loading...</option>
            </select>
        </div>
        
        <div id="metricsContainer"></div>
        
        <div class="table-container" style="margin-bottom: 25px;">
            <div class="table-title">Trend Analysis</div>
            <div style="margin-bottom: 15px;">
                <label>Select Metric to Chart:</label>
                <select id="chartMetricSelect" style="min-width: 250px;">
                    <option value="">Choose a metric...</option>
                </select>
            </div>
            <canvas id="trendChart" style="max-height: 400px;"></canvas>
        </div>
        
        <div class="table-container">
            <div class="table-title">Metrics - Year to Year</div>
            <table id="dataTableYear">
                <thead>
                    <tr id="tableHeaderYear">
                        <th>Metric</th>
                    </tr>
                </thead>
                <tbody id="tableBodyYear">
                </tbody>
            </table>
        </div>
        
        <div class="table-container">
            <div class="table-title">Metrics - Term to Term</div>
            <table id="dataTableTerm">
                <thead>
                    <tr id="tableHeaderTerm">
                        <th>Metric</th>
                    </tr>
                </thead>
                <tbody id="tableBodyTerm">
                </tbody>
            </table>
        </div>
    </div>
    
    <script>
        let allData = [];
        let currentDept = 'CLAS';
        let trendChart = null;
        
        const metricGroups = {
            'Enrollment': ['CHP', 'FTEs', 'Seats_Filled', 'Majors', 'Online_CHP'],
            'Retention': ['Retention', 'Retention_FTFT', 'Retention_Transfer'],
            'Graduation': ['Graduates', 'Grad_4_Year', 'Grad_6_Year'],
            'Fiscal Health': ['Profit_Loss', 'Avg_Class_Size', 'Fill_Rate']
        };
        
        const metricLabels = {
            'CHP': 'Credit Hours Produced',
            'FTEs': 'FTEs',
            'Seats_Filled': 'Seats Filled',
            'Majors': 'Total Majors',
            'Online_CHP': 'Online CHP %',
            'Retention': 'Overall Retention',
            'Retention_FTFT': 'FTFT Retention',
            'Retention_Transfer': 'Transfer Retention',
            'Graduates': 'Graduates',
            'Grad_4_Year': '4-Year Grad Rate',
            'Grad_5_Year': '5-Year Grad Rate',
            'Grad_6_Year': '6-Year Grad Rate',
            'Profit_Loss': 'Profit/Loss',
            'Avg_Class_Size': 'Avg Class Size',
            'Fill_Rate': 'Fill Rate',
            'DFWI': 'DFWI Rate'
        };
        
        function formatValue(metric, value) {
            if (value === null || value === undefined || value === '' || value === 'null') return '-';
            
            const strValue = String(value).trim();
            if (strValue === '') return '-';
            
            if (strValue.includes('$')) {
                return strValue;
            }
            
            const v = parseFloat(strValue);
            if (isNaN(v)) return strValue;
            
            if (metric.includes('Rate') || metric === 'Retention' || metric.includes('Retention_') || 
                metric === 'DFWI' || metric.includes('Grad_') || metric === 'Online_CHP') {
                return (v * 100).toFixed(1) + '%';
            }
            if (metric === 'Profit_Loss') {
                // Display as profit/loss per dollar (e.g., $0.23 or ($0.33))
                if (v < 0) {
                    return '($' + Math.abs(v).toFixed(2) + ')';
                } else {
                    return '$' + v.toFixed(2);
                }
            }
            if (metric === 'Avg_Class_Size') {
                return v.toFixed(1);
            }
            if (metric === 'CHP' || metric === 'FTEs' || metric === 'Seats_Filled') {
                return Math.round(v).toLocaleString();
            }
            return Math.round(v).toLocaleString();
        }
        
        function parseValue(value) {
            if (value === null || value === undefined || value === '' || value === 'null') return null;
            const strValue = String(value).trim();
            if (strValue === '') return null;
            if (strValue.includes('$')) {
                // Handle accounting format: ($0.33) means -0.33
                let numStr = strValue.replace(/\$/g, '').replace(/\s/g, '');
                if (numStr.startsWith('(') && numStr.endsWith(')')) {
                    numStr = '-' + numStr.substring(1, numStr.length - 1);
                }
                return parseFloat(numStr);
            }
            const v = parseFloat(strValue);
            return isNaN(v) ? null : v;
        }
        
        function getLatestValue(dept, metric, yearPattern) {
            const matches = allData.filter(d => 
                d.Department === dept && 
                d.Metric === metric && 
                d['Year/Term'] && 
                d['Year/Term'].includes(yearPattern)
            );
            return matches.length > 0 ? matches[matches.length - 1] : null;
        }
        
        function getMostRecentValue(dept, metric) {
            const matches = allData.filter(d => 
                d.Department === dept && 
                d.Metric === metric && 
                d['Year/Term'] && 
                d.Value !== null && 
                d.Value !== undefined && 
                d.Value !== ''
            );
            
            if (matches.length === 0) return null;
            
            // Sort by year/term with proper date logic
            matches.sort((a, b) => {
                const termA = a['Year/Term'];
                const termB = b['Year/Term'];
                
                // Extract year from term
                const yearA = parseInt(termA.match(/\d{4}/)?.[0] || '0');
                const yearB = parseInt(termB.match(/\d{4}/)?.[0] || '0');
                
                if (yearA !== yearB) return yearB - yearA;
                
                // If same year, Fall > Spring
                if (termA.includes('Fall') && termB.includes('Spring')) return -1;
                if (termA.includes('Spring') && termB.includes('Fall')) return 1;
                
                // Otherwise compare alphabetically
                return termB.localeCompare(termA);
            });
            return matches[0];
        }
        
        function getPreviousValue(dept, metric, currentYearTerm) {
            // Extract the term type (Fall/Spring) and year from current
            const currentYear = parseInt(currentYearTerm.match(/\d{4}/)?.[0] || '0');
            const currentTerm = currentYearTerm.includes('Fall') ? 'Fall' : 
                              currentYearTerm.includes('Spring') ? 'Spring' : null;
            
            // If it's an academic year format (e.g., "2024-2025"), find previous academic year
            if (currentYearTerm.includes('-')) {
                const matches = allData.filter(d => 
                    d.Department === dept && 
                    d.Metric === metric && 
                    d['Year/Term'] && 
                    d['Year/Term'].includes('-') &&
                    d['Year/Term'] !== currentYearTerm &&
                    d.Value !== null && 
                    d.Value !== undefined && 
                    d.Value !== ''
                );
                
                if (matches.length === 0) return null;
                
                // Sort descending and return most recent before current
                matches.sort((a, b) => b['Year/Term'].localeCompare(a['Year/Term']));
                return matches[0];
            }
            
            // For term-based metrics (Fall/Spring), find the same term from previous year
            if (currentTerm) {
                const matches = allData.filter(d => 
                    d.Department === dept && 
                    d.Metric === metric && 
                    d['Year/Term'] && 
                    d['Year/Term'].includes(currentTerm) &&
                    d['Year/Term'] !== currentYearTerm &&
                    d.Value !== null && 
                    d.Value !== undefined && 
                    d.Value !== ''
                );
                
                if (matches.length === 0) return null;
                
                // Sort by year descending to get most recent same-term
                matches.sort((a, b) => {
                    const yearA = parseInt(a['Year/Term'].match(/\d{4}/)?.[0] || '0');
                    const yearB = parseInt(b['Year/Term'].match(/\d{4}/)?.[0] || '0');
                    return yearB - yearA;
                });
                
                return matches[0];
            }
            
            // Fallback for other formats
            const matches = allData.filter(d => 
                d.Department === dept && 
                d.Metric === metric && 
                d['Year/Term'] && 
                d['Year/Term'] !== currentYearTerm &&
                d.Value !== null && 
                d.Value !== undefined && 
                d.Value !== ''
            );
            
            if (matches.length === 0) return null;
            matches.sort((a, b) => b['Year/Term'].localeCompare(a['Year/Term']));
            return matches[0];
        }
        
        // Load CSV file from same folder
        Papa.parse('CLAS_Data_Dashboard.csv', {
            download: true,
            header: true,
            complete: function(results) {
                allData = results.data.filter(row => 
                    row.Department && row.Metric && row['Year/Term'] && row.Value
                );
                if (allData.length === 0) {
                    showError('CSV file loaded but no valid data found. Please check the file format.');
                } else {
                    initializeDashboard();
                }
            },
            error: function(error) {
                showError('Could not load CLAS_Data_Dashboard.csv. Make sure it is in the same folder as this HTML file.');
                console.error(error);
            }
        });
        
        function showError(message) {
            const errorContainer = document.getElementById('errorContainer');
            errorContainer.innerHTML = `<div class="error-message"><strong>Error:</strong> ${message}</div>`;
            document.getElementById('subtitle').textContent = 'Error loading data';
        }
        
        function initializeDashboard() {
            // Set the current date in the subtitle
            const today = new Date();
            const formattedDate = today.toLocaleDateString('en-US', { 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            });
            document.getElementById('subtitle').textContent = `Data refreshed on ${formattedDate}`;
            
            // Put CLAS first, then sort the rest alphabetically
            const otherDepts = [...new Set(allData.map(d => d.Department).filter(d => d !== 'CLAS'))].sort();
            const depts = ['CLAS', ...otherDepts];
            
            const deptSelect = document.getElementById('deptSelect');
            deptSelect.innerHTML = '';
            
            depts.forEach(d => {
                const opt = document.createElement('option');
                opt.value = d;
                opt.textContent = d === 'CLAS' ? 'CLAS (All Departments)' : d;
                deptSelect.appendChild(opt);
            });
            
            deptSelect.value = 'CLAS';
            deptSelect.addEventListener('change', function() {
                currentDept = this.value;
                updateChartMetricOptions(); // Update available metrics
                updateDashboard();
            });
            
            // Populate chart metric selector
            const chartMetricSelect = document.getElementById('chartMetricSelect');
            
            // Function to populate metrics based on current department
            function updateChartMetricOptions() {
                // Get metrics that have data for current department
                const availableMetrics = [...new Set(allData
                    .filter(d => d.Department === currentDept)
                    .map(d => d.Metric)
                )].sort();
                
                const currentSelection = chartMetricSelect.value;
                chartMetricSelect.innerHTML = '<option value="">Choose a metric...</option>';
                
                availableMetrics.forEach(metric => {
                    const opt = document.createElement('option');
                    opt.value = metric;
                    opt.textContent = metricLabels[metric] || metric;
                    chartMetricSelect.appendChild(opt);
                });
                
                // Restore selection if still available
                if (availableMetrics.includes(currentSelection)) {
                    chartMetricSelect.value = currentSelection;
                    updateTrendChart(currentSelection);
                } else {
                    // Clear chart if previous metric not available
                    if (trendChart) {
                        trendChart.destroy();
                        trendChart = null;
                    }
                }
            }
            
            updateChartMetricOptions();
            
            chartMetricSelect.addEventListener('change', function() {
                if (this.value) {
                    updateTrendChart(this.value);
                } else if (trendChart) {
                    trendChart.destroy();
                    trendChart = null;
                }
            });
            
            updateDashboard();
        }
        
        function updateDashboard() {
            updateMetricCards();
            updateTables();
            
            // Update chart if a metric is selected
            const selectedMetric = document.getElementById('chartMetricSelect').value;
            if (selectedMetric) {
                updateTrendChart(selectedMetric);
            }
        }
        
        function updateMetricCards() {
            const container = document.getElementById('metricsContainer');
            container.innerHTML = '';
            
            Object.keys(metricGroups).forEach(groupName => {
                const section = document.createElement('div');
                section.className = 'metric-section';
                
                const title = document.createElement('div');
                title.className = 'section-title';
                title.textContent = groupName;
                section.appendChild(title);
                
                const kpiContainer = document.createElement('div');
                kpiContainer.className = 'kpi-container';
                
                metricGroups[groupName].forEach(metric => {
                    const current = getMostRecentValue(currentDept, metric);
                    
                    if (!current) return;
                    
                    const previous = getPreviousValue(currentDept, metric, current['Year/Term']);
                    
                    const cv = parseValue(current.Value);
                    const pv = previous ? parseValue(previous.Value) : null;
                    const change = (cv !== null && pv !== null) ? ((cv - pv) / pv * 100) : null;
                    
                    const card = document.createElement('div');
                    card.className = 'kpi-card';
                    
                    let changeClass = 'neutral';
                    let arrow = '';
                    if (change !== null) {
                        // DFWI: lower is better (down = green, up = red)
                        // All other metrics: higher is better (up = green, down = red)
                        if (metric === 'DFWI') {
                            changeClass = change < 0 ? 'positive' : change > 0 ? 'negative' : 'neutral';
                        } else {
                            changeClass = change > 0 ? 'positive' : change < 0 ? 'negative' : 'neutral';
                        }
                        arrow = change > 0 ? '↑' : change < 0 ? '↓' : '→';
                    }
                    
                    // Create title with year/term in parentheses
                    const metricTitle = `${metricLabels[metric] || metric} (${current['Year/Term']})`;
                    
                    card.innerHTML = `
                        <div class="kpi-label">${metricTitle}</div>
                        <div class="kpi-value">${formatValue(metric, current.Value)}</div>
                        ${change !== null ? 
                            `<div class="kpi-change ${changeClass}">${arrow} ${Math.abs(change).toFixed(1)}% vs ${previous['Year/Term']}</div>` 
                            : '<div class="kpi-change neutral">No prior year data</div>'}
                    `;
                    kpiContainer.appendChild(card);
                });
                
                if (kpiContainer.children.length > 0) {
                    section.appendChild(kpiContainer);
                    container.appendChild(section);
                }
            });
        }
        
        function updateTables() {
            updateYearTable();
            updateTermTable();
        }
        
        function updateYearTable() {
            // Get all academic years (YYYY-YYYY format) and sort in reverse
            const years = [...new Set(allData
                .filter(d => d.Department === currentDept)
                .map(d => d['Year/Term'])
                .filter(y => y && y.includes('-'))
            )].sort().reverse();
            
            const headerRow = document.getElementById('tableHeaderYear');
            headerRow.innerHTML = '<th>Metric</th>';
            years.forEach(year => {
                const th = document.createElement('th');
                th.textContent = year;
                headerRow.appendChild(th);
            });
            
            const metrics = [...new Set(allData
                .filter(d => d.Department === currentDept)
                .map(d => d.Metric)
            )].sort();
            
            const tbody = document.getElementById('tableBodyYear');
            tbody.innerHTML = '';
            
            metrics.forEach(metric => {
                // Check if this metric has any year-based data
                const hasYearData = years.some(year => {
                    return allData.some(d => 
                        d.Department === currentDept && 
                        d.Metric === metric && 
                        d['Year/Term'] === year &&
                        d.Value !== null &&
                        d.Value !== undefined &&
                        d.Value !== ''
                    );
                });
                
                // Only show this row if there's at least one year with data
                if (!hasYearData) return;
                
                const row = document.createElement('tr');
                const nameCell = document.createElement('td');
                nameCell.className = 'metric-name';
                nameCell.textContent = metricLabels[metric] || metric;
                row.appendChild(nameCell);
                
                years.forEach(year => {
                    const dataPoint = allData.find(d => 
                        d.Department === currentDept && 
                        d.Metric === metric && 
                        d['Year/Term'] === year
                    );
                    
                    const cell = document.createElement('td');
                    cell.textContent = dataPoint ? formatValue(metric, dataPoint.Value) : '-';
                    row.appendChild(cell);
                });
                
                tbody.appendChild(row);
            });
        }
        
        function updateTermTable() {
            // Get all terms (Fall/Spring) in reverse chronological order
            const terms = [...new Set(allData
                .filter(d => d.Department === currentDept)
                .map(d => d['Year/Term'])
                .filter(y => y && (y.includes('Fall') || y.includes('Spring')))
            )].sort((a, b) => {
                // Helper function to get sort key
                const getSortKey = (period) => {
                    const yearMatch = period.match(/\d{4}/);
                    if (!yearMatch) return 0;
                    
                    const year = parseInt(yearMatch[0]);
                    const isFall = period.toLowerCase().includes('fall');
                    const isSpring = period.toLowerCase().includes('spring');
                    
                    // For academic calendar: Fall 2021, Spring 2022, Fall 2022, Spring 2023...
                    // Fall semester: use year as-is, add 0
                    // Spring semester: subtract 1 from year, add 5
                    if (isFall) return year * 10 + 0;
                    if (isSpring) return (year - 1) * 10 + 5;
                    return year * 10;
                };
                
                return getSortKey(b) - getSortKey(a);
            });
            
            const headerRow = document.getElementById('tableHeaderTerm');
            headerRow.innerHTML = '<th>Metric</th>';
            terms.forEach(term => {
                const th = document.createElement('th');
                th.textContent = term;
                headerRow.appendChild(th);
            });
            
            const metrics = [...new Set(allData
                .filter(d => d.Department === currentDept)
                .map(d => d.Metric)
            )].sort();
            
            const tbody = document.getElementById('tableBodyTerm');
            tbody.innerHTML = '';
            
            metrics.forEach(metric => {
                // Check if this metric has any term-based data
                const hasTermData = terms.some(term => {
                    return allData.some(d => 
                        d.Department === currentDept && 
                        d.Metric === metric && 
                        d['Year/Term'] === term &&
                        d.Value !== null &&
                        d.Value !== undefined &&
                        d.Value !== ''
                    );
                });
                
                // Only show this row if there's at least one term with data
                if (!hasTermData) return;
                
                const row = document.createElement('tr');
                const nameCell = document.createElement('td');
                nameCell.className = 'metric-name';
                nameCell.textContent = metricLabels[metric] || metric;
                row.appendChild(nameCell);
                
                terms.forEach(term => {
                    const dataPoint = allData.find(d => 
                        d.Department === currentDept && 
                        d.Metric === metric && 
                        d['Year/Term'] === term
                    );
                    
                    const cell = document.createElement('td');
                    cell.textContent = dataPoint ? formatValue(metric, dataPoint.Value) : '-';
                    row.appendChild(cell);
                });
                
                tbody.appendChild(row);
            });
        }
        
        function updateTrendChart(metric) {
            // Get all data points for this department and metric
            const chartData = allData
                .filter(d => d.Department === currentDept && d.Metric === metric)
                .map(d => ({
                    period: d['Year/Term'],
                    value: parseValue(d.Value)
                }))
                .filter(d => d.value !== null)
                .sort((a, b) => {
                    const periodA = a.period;
                    const periodB = b.period;
                    
                    // Helper function to get sort key
                    const getSortKey = (period) => {
                        const yearMatch = period.match(/\d{4}/);
                        if (!yearMatch) return 0;
                        
                        const year = parseInt(yearMatch[0]);
                        const isFall = period.toLowerCase().includes('fall');
                        const isSpring = period.toLowerCase().includes('spring');
                        
                        // For academic calendar: Fall 2021, Spring 2022, Fall 2022, Spring 2023...
                        // Fall semester: use year as-is, add 0
                        // Spring semester: subtract 1 from year, add 5
                        if (isFall) return year * 10 + 0;
                        if (isSpring) return (year - 1) * 10 + 5;
                        return year * 10; // For academic years
                    };
                    
                    return getSortKey(periodA) - getSortKey(periodB);
                });
            
            if (chartData.length === 0) {
                if (trendChart) {
                    trendChart.destroy();
                    trendChart = null;
                }
                return;
            }
            
            const ctx = document.getElementById('trendChart');
            
            if (trendChart) {
                trendChart.destroy();
            }
            
            trendChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartData.map(d => d.period),
                    datasets: [{
                        label: metricLabels[metric] || metric,
                        data: chartData.map(d => d.value),
                        borderColor: '#00447c',
                        backgroundColor: 'rgba(0, 68, 124, 0.1)',
                        tension: 0.3,
                        fill: true,
                        pointRadius: 4,
                        pointHoverRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        title: {
                            display: true,
                            text: `${metricLabels[metric] || metric} - ${currentDept === 'CLAS' ? 'All Departments' : currentDept}`,
                            font: {
                                size: 16,
                                weight: 'bold'
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    label += formatValue(metric, context.parsed.y);
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            ticks: {
                                callback: function(value) {
                                    return formatValue(metric, value);
                                }
                            }
                        }
                    }
                }
            });
        }
    </script>
</body>
</html>